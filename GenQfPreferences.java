import java.nio.file.Path;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

@SuppressWarnings("unchecked")
public class GenQfPreferences {
    private static final String PREFS_CLASS = "org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences";

    public static void run(String reportedJar) throws Throwable {
        Path outputPythonFile = Path.of("qf_prefs.py");
        List<String> outputLines = new ArrayList<>(List.of(
            "from __future__ import annotations",
            "from typing import Annotated",
            "",
            "# This file is generated by GenQfPreferences.java",
            "# Do not edit this file directly!",
            "",
            "", // PEP 8 requests two blank lines before class definition
            "class IFernflowerPreferences:",
            "\t\"\"\"",
            "\tThis class contains all the preferences that can be used to configure the decompiler.",
            "",
            "\tThese are the descriptions that Quiltflower provides for each preference:"
        ));

        List<String> outputLines2 = new ArrayList<>();

        try {
            // Reflection to avoid runtime dependency on Quiltflower
            Class<?> c = Class.forName(PREFS_CLASS);
            var Name = (Class<? extends Annotation>) Class.forName("org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences$Name");
            var Description = (Class<? extends Annotation>) Class.forName("org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences$Description");

            var nValue = Name.getMethod("value");
            var dValue = Description.getMethod("value");

            for (Field f : c.getDeclaredFields()) {
                if (Modifier.isStatic(f.getModifiers()) && f.getType() == String.class) {
                    String prefReferenceName = f.getName();
                    String prefValue = (String) f.get(null);
                    var nameAnno = f.getAnnotation(Name);
                    var descAnno = f.getAnnotation(Description);

                    if (nameAnno == null || descAnno == null) {
                        System.err.println("WARNING: Missing annotation for " + prefReferenceName + "; skipping");
                        continue;
                    }

                    String prefFriendlyName = (String) nValue.invoke(nameAnno);
                    String prefDescription = (String) dValue.invoke(descAnno);

                    char quote = prefFriendlyName.contains("'") ? '"' : '\'';

                    outputLines.add(String.format("\t%s: %s", prefFriendlyName, prefDescription));
                    outputLines2.add(String.format("\t%s: Annotated[str, %c%s%c] = \"%s\"", prefReferenceName, quote, prefFriendlyName, quote, prefValue));
                }
            }
        } catch (ClassNotFoundException | NoClassDefFoundError e) {
            // Attempt to load QF jar from relative path
            if (reportedJar == null) {
                Path jars = Path.of("jars");
                List<Path> jarFiles;
                try (var stream = Files.list(jars)) {
                    jarFiles = stream
                        .filter(p -> p.getFileName().toString().endsWith(".jar"))
                        .map(p -> p.getFileName().toString())
                        .sorted(Comparator.naturalOrder())
                        .map(jars::resolve)
                        .toList();
                }
                Path newestByVersion = jarFiles.get(jarFiles.size() - 1);
                reportedJar = newestByVersion.getFileName().toString();
            }
            System.err.println("WARNING: Could not find Quiltflower classes, attempting to load from " + reportedJar);

            if (!Files.exists(Path.of("GenQfPreferences.class"))) {
                Process p = new ProcessBuilder("javac", "GenQfPreferences.java")
                    .inheritIO()
                    .start();
                p.waitFor();
                if (p.exitValue() != 0) {
                    System.exit(p.exitValue());
                }
            }

            String jar = Path.of("jars", reportedJar).toString();
            String cp = String.join(System.getProperty("path.separator"), List.of(
                jar,
                "."
            ));

            Process p = new ProcessBuilder("java", "-cp", cp, "GenQfPreferences")
                .inheritIO()
                .start();
            p.waitFor();
            System.exit(p.exitValue());
        }

        outputLines.add("\t\"\"\"");
        outputLines.add("");
        outputLines.addAll(outputLines2);

        outputLines.add(""); // EOF newline

        Files.write(outputPythonFile, outputLines);
    }

    public static void main(String[] args) {
        try {
            String reportedJar = args.length > 0 ? args[0] : null;
            run(reportedJar);
        } catch (Throwable t) {
            var rethrower = new Object() {
                public <T extends Throwable> void rethrow(Throwable t) throws T {
                    throw (T) t;
                }
            };
            rethrower.rethrow(t);
        }
    }
}